# -*- coding: utf-8 -*-
"""Data Toolkit_Assignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aWssed8xopmfRz-N-dpFJQCF9FJ_Sf1D

# Theoretical Questions

**Q1. What is NumPy, and why is it widely used in Python?**

**Ans:** **NumPy** (Numerical Python) is a fundamental library for scientific computing in Python. It provides support for large, multi-dimensional arrays and matrices, along with mathematical functions to operate on them.

**Why it's widely used:**
- **Speed**: NumPy operations are implemented in C, making them much faster than pure Python
- **Memory Efficiency**: Arrays use less memory than Python lists
- **Broadcasting**: Allows operations between arrays of different shapes
- **Foundation**: Many other libraries (Pandas, Matplotlib, Scikit-learn) are built on NumPy

**Example:**
```python
import numpy as np
# Creating arrays is faster and more memory-efficient
np_array = np.array([1, 2, 3, 4, 5])  # NumPy array
python_list = [1, 2, 3, 4, 5]        # Python list
```

**Q2. How does broadcasting work in NumPy?**

**Ans:** **Broadcasting** is NumPy's ability to perform operations on arrays with different shapes without explicitly reshaping them. It follows specific rules to "broadcast" smaller arrays across larger ones.

**Broadcasting Rules:**
1. Arrays are aligned from the rightmost dimension
2. Dimensions of size 1 can be "stretched" to match larger dimensions
3. Missing dimensions are assumed to be size 1

**Example:**
"""

import numpy as np
a = np.array([[1, 2, 3],     # Shape: (2, 3)
              [4, 5, 6]])
b = np.array([10, 20, 30])   # Shape: (3,) -> broadcasts to (2, 3)

result = a + b

print(result)

"""**Q3. What is a Pandas DataFrame?**

**Ans:** A **DataFrame** is a 2-dimensional labeled data structure in Pandas, similar to a table in Excel or SQL. It's the most commonly used Pandas object for data manipulation and analysis.

**Key Features:**
- **Rows and Columns**: Like a spreadsheet with labeled rows and columns
- **Different Data Types**: Each column can contain different data types
- **Indexing**: Rows and columns have labels for easy access
- **Missing Data Handling**: Built-in support for NaN values

**Example:**
"""

import pandas as pd
df = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [25, 30, 35],
    'City': ['New York', 'London', 'Tokyo']
})
df

"""**Q4. Explain the use of the groupby() method in Pandas.**

**Ans:** **groupby()** is used to split data into groups based on some criteria, then apply a function to each group independently. It follows the "split-apply-combine" paradigm.

**Common Use Cases:**
- Calculate statistics for different categories
- Aggregate data by groups
- Transform data within groups

**Example:**

"""

import pandas as pd
sales_data = pd.DataFrame({
    'Product': ['A', 'B', 'A', 'B', 'A'],
    'Region': ['North', 'South', 'North', 'South', 'North'],
    'Sales': [100, 150, 200, 120, 80]
})

# Group by Product and calculate mean sales
grouped = sales_data.groupby('Product')['Sales'].mean()
grouped

"""**Q5. Why is Seaborn preferred for statistical visualizations?**

**Ans:**

**Seaborn** is built on top of Matplotlib but provides higher-level, more attractive statistical visualizations with less code.

**Advantages:**
- **Built-in Statistical Functions**: Automatically calculates and displays statistical relationships
- **Beautiful Default Styles**: Professional-looking plots out of the box
- **Easy Complex Plots**: Creates complex statistical plots with simple commands
- **Pandas Integration**: Works seamlessly with DataFrames

**Example:**
```python
import seaborn as sns
import matplotlib.pyplot as plt

# Create a correlation heatmap with just one line
sns.heatmap(df.corr(), annot=True)
# Much simpler than doing this in pure Matplotlib!
```

**6. What are the differences between NumPy arrays and Python lists?**

**Ans:**

| Feature | NumPy Arrays | Python Lists |
|---------|--------------|--------------|
| **Speed** | Fast (C implementation) | Slower (Python implementation) |
| **Memory** | Memory efficient | More memory overhead |
| **Data Types** | Homogeneous (same type) | Heterogeneous (mixed types) |
| **Operations** | Vectorized operations | Element-by-element loops |
| **Size** | Fixed size | Dynamic size |

**Example:**
"""

import numpy as np

# Python list - can contain different types
python_list = [1, 'hello', 3.14, True]
print("Python list (mixed types):", python_list)

# NumPy array - all elements same type
numpy_array = np.array([1, 2, 3, 4])
print("NumPy array (same type):", numpy_array)
print("Array data type:", numpy_array.dtype)

# Vectorized operation (fast)
result = numpy_array * 2
print("Vectorized result:", result)

# List requires loop (slower)
result_list = [x * 2 for x in [1, 2, 3, 4]]
print("List result:", result_list)

"""**Q7. What is a heatmap, and when should it be used?**

**Ans:** A **heatmap** is a data visualization technique that uses colors to represent values in a matrix. Darker/lighter colors typically represent higher/lower values.

**When to Use:**
- **Correlation Matrices**: Show relationships between variables
- **Confusion Matrices**: Evaluate classification models
- **Time Series Data**: Show patterns over time and categories
- **Geographic Data**: Display data intensity across regions

**Example:**

"""

import seaborn as sns
import matplotlib.pyplot as plt

# Load sample data
df = sns.load_dataset('iris')

# Select only numeric columns for correlation calculation
numeric_df = df.select_dtypes(include='number')

# Create correlation matrix and visualize
correlation_matrix = numeric_df.corr()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Iris Features Correlation')
plt.show()

# Colors show strength of correlation between variables
# Red = positive correlation, Blue = negative correlation

"""**Q8. What does the term "vectorized operation" mean in NumPy?**

**Ans:** **Vectorized operations** apply mathematical operations to entire arrays at once, rather than using explicit loops. This is much faster because the operations are implemented in optimized C code.

**Benefits:**
- **Speed**: 10-100x faster than Python loops
- **Readable Code**: More concise and clear
- **Memory Efficient**: Optimized memory access patterns

**Example:**

"""

import numpy as np
import time

# Large array for timing
arr = np.random.randint(1, 10, 100000)

# Time vectorized
start = time.time()
result1 = arr * 2
time1 = time.time() - start

# Time non-vectorized
start = time.time()
result2 = [x * 2 for x in arr]
time2 = time.time() - start

print(f"Vectorized: {time1:.4f} seconds")
print(f"Non-vectorized: {time2:.4f} seconds")
print(f"NumPy is {time2/time1:.1f}x faster!")

"""**Q9. How does Matplotlib differ from Plotly?**


**Ans:**

| Feature | Matplotlib | Plotly |
|---------|------------|--------|
| **Interactivity** | Static plots (mostly) | Interactive by default |
| **Ease of Use** | More code required | Simpler syntax |
| **Customization** | Highly customizable | Good customization |
| **Web Integration** | Limited | Excellent web support |
| **3D Plots** | Basic 3D support | Advanced 3D capabilities |

**Example:**
"""

# Matplotlib - Static plot
import matplotlib.pyplot as plt
plt.plot([1, 2, 3], [4, 5, 6])
plt.show()

# Plotly - Interactive plot
import plotly.express as px
fig = px.line(x=[1, 2, 3], y=[4, 5, 6])
fig.show()  # Can zoom, pan, hover for values

"""**Q10. What is the significance of hierarchical indexing in Pandas?**

**Ans:** **Hierarchical indexing** (MultiIndex) allows you to work with higher-dimensional data in a lower-dimensional structure. It's like having multiple levels of row or column labels.

**Benefits:**
- **Data Organization**: Structure complex datasets logically
- **Memory Efficiency**: Avoid data duplication
- **Easy Aggregation**: Group and analyze at different levels

**Example:**
"""

import pandas as pd

# MultiIndex DataFrame
index = pd.MultiIndex.from_tuples([
    ('2023', 'Q1'), ('2023', 'Q2'),
    ('2024', 'Q1'), ('2024', 'Q2')
], names=['Year', 'Quarter'])

df = pd.DataFrame({'Sales': [100, 150, 120, 180]}, index=index)

# Easy to access data at different levels
print(df.loc['2023'])  # All 2023 data
print(df.loc[('2023', 'Q1')])  # Specific quarter

"""
**Q11. What is the role of Seaborn's `pairplot ()` function ?**

**Ans:** **`pairplot()`** creates a matrix of scatter plots showing relationships between all pairs of numerical variables in a dataset. The diagonal shows the distribution of each variable.

**Uses:**
- **Exploratory Data Analysis**: Quickly visualize all variable relationships
- **Correlation Discovery**: Identify patterns and correlations
- **Outlier Detection**: Spot unusual data points

**Example:**"""

import seaborn as sns
import matplotlib.pyplot as plt

# Load the built-in iris dataset
iris_dataset = sns.load_dataset('iris')

print("Iris dataset preview:")
print(iris_dataset.head())

# Creates scatter plots for all variable pairs
sns.pairplot(iris_dataset, hue='species')
plt.show()

# Shows relationships between sepal length, width, petal length, width
# Colored by species (setosa, versicolor, virginica)

"""**Q12. What is the purpose of the `describe()` function in Pandas?**

**Ans:** **`describe()`** generates descriptive statistics for numerical columns in a DataFrame, providing a quick summary of the data distribution.

**Statistics Provided:**
- **`count`**: Number of non-null values
- **`mean`**: Average value
- **`std`**: Standard deviation
- **`min/max`**: Minimum and maximum values
- **`25%, 50%, 75%`**: Quartiles (percentiles)

**Example:**
```python
import pandas as pd
df = pd.DataFrame({'Age': [25, 30, 35, 40, 45]})
summary = df.describe()
# Returns count, mean, std, min, 25%, 50%, 75%, max for Age column
```

**Q13. Why is handling missing data important in Pandas?**

**Ans:** **Missing data** can severely impact analysis results and model performance. Proper handling ensures data quality and reliable insights.

**Problems with Missing Data:**
- **Biased Results**: Can skew statistical calculations
- **Model Errors**: Many algorithms can't handle NaN values
- **Reduced Sample Size**: May lose valuable information

**Handling Strategies:**
- **Drop**: Remove rows/columns with missing values
- **Fill**: Replace with mean, median, or specific values
- **Interpolate**: Estimate based on surrounding values

**Example:**
"""

import pandas as pd
import numpy as np

df = pd.DataFrame({
    'A': [1, 2, np.nan, 4],
    'B': [5, np.nan, 7, 8]
})

# check for missing data
print(df.isnull().sum())

# Handle missing data
df_filled = df.fillna(df.mean())  # Fill with column mean
df_dropped = df.dropna()          # Remove rows with any NaN

"""
**Q14. What are the benefits of using Plotly for data visualization?**

**Ans:** **Plotly** offers several advantages for creating interactive, publication-ready visualizations:

**Key Benefits:**
- **Interactivity**: Built-in zoom, pan, hover, and selection
- **Web-Ready**: Easy to embed in web applications
- **Professional Quality**: Publication-ready plots
- **Multiple Languages**: Works with Python, R, JavaScript
- **3D Visualization**: Advanced 3D plotting capabilities

**Example:**"""

import plotly.express as px
import pandas as pd

# Sample data
df = pd.DataFrame({
    'height': [165, 180, 170, 175, 160],
    'weight': [65, 80, 70, 75, 55],
    'name': ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve'],
    'age': [25, 30, 28, 35, 22]
})

# Interactive scatter plot with hover information
fig = px.scatter(df, x='height', y='weight',
                hover_data=['name', 'age'],
                title='Height vs Weight')

fig.show()  # Interactive plot - hover to see name & age!

"""**Q15. How does NumPy handle multidimensional arrays?**

**Ans:** **NumPy** provides powerful support for arrays of any dimension, treating them as n-dimensional arrays (ndarrays).

**Key Features:**
- **Shape**: Describes dimensions (e.g., (3, 4) for 3 rows, 4 columns)
- **Indexing**: Access elements using [row, column] syntax
- **Broadcasting**: Operations across different dimensions
- **Reshaping**: Change array dimensions without copying data


**Example:**
"""

import numpy as np

# 2D array (matrix)
arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6]])
print(arr_2d.shape)

# 3D array
arr_3d = np.array([[[1, 2], [3, 4]],
                   [[5, 6], [7, 8]]])
print(arr_3d.shape)

# Access elements
print(arr_2d[0, 1])    # Element at row 0, column 1
print(arr_3d[1, 0, 1]) # Element at depth 1, row 0, column 1

"""**Q16. What is the role of Bokeh in data visualization?**

**Ans:** **Bokeh** is a Python library for creating interactive web-based visualizations that can handle large datasets efficiently.

**Key Features:**
- **Web-Native**: Built for modern web browsers
- **Big Data**: Handles millions of data points efficiently
- **Interactive**: Rich interactions without writing JavaScript
- **Server Applications**: Can create dashboard applications

**Use Cases:**
- **Dashboards**: Interactive business intelligence dashboards
- **Real-time Data**: Streaming data visualizations
- **Large Datasets**: When Matplotlib becomes too slow
- **Web Applications**: Embedded interactive charts

**Example:**
"""

from bokeh.plotting import figure, show
from bokeh.io import output_notebook

output_notebook()

# Sample data
x_data = [1, 2, 3, 4, 5]
y_data = [2, 5, 3, 8, 7]

# Interactive plot
p = figure(tools="pan,wheel_zoom,reset,hover", width=400, height=300)
p.circle(x_data, y_data, size=15, alpha=0.7, color='blue')
p.title.text = "Interactive Scatter Plot"

show(p)

"""**Q17. Explain the difference between `apply()` and `map()` in Pandas.**


**Ans:** Both **apply()** and **map()** transform data, but they work differently:

**apply():**
- Works on DataFrames and Series
- Can apply functions along rows or columns
- More flexible and powerful
- Can return Series or DataFrames

**map():**
- Only works on Series
- Element-wise transformation
- Faster for simple transformations
- Always returns a Series

**Examples:**

```python
import pandas as pd

df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})

# apply() - can work on entire DataFrame
df_result = df.apply(lambda x: x.sum(), axis=0)  # Sum each column
print(df_result)

# map() - only on Series, element-wise
mapping = {1: 'one', 2: 'two', 3: 'three'}
series_result = df['A'].map(mapping)  # Maps values using dictionary
print (series_result)

# apply() on Series (similar to map but more flexible)
series_result2 = df['A'].apply(lambda x: x ** 2)  # Square each element
print(series_result2)
```

**Q18. What are some advanced features of NumPy?**

**Ans:** **NumPy** offers many sophisticated features beyond basic arrays:

**Advanced Features:**
- **Broadcasting**: Operations between different-shaped arrays
- **Fancy Indexing**: Using arrays as indices
- **Boolean Indexing**: Filter arrays using boolean conditions
- **Universal Functions (ufuncs)**: Optimized element-wise operations
- **Linear Algebra**: Matrix operations, eigenvalues, decompositions
- **Memory Views**: Efficient array slicing without copying

**Examples:**

```python

import numpy as np

# Fancy indexing
arr = np.array([10, 20, 30, 40, 50])
indices = np.array([0, 2, 4])
result = arr[indices]  # [10, 30, 50]
print(result)

# Boolean indexing
mask = arr > 25
filtered = arr[mask]  # [30, 40, 50]
print(filtered)

# Broadcasting with different shapes
matrix = np.array([[1, 2, 3], [4, 5, 6]])
vector = np.array([10, 20, 30])
result = matrix + vector  # Adds vector to each row
print(result)

```

**Q19. How does Pandas simplify time series analysis?**

**Ans:** **Pandas** provides specialized tools for working with time-indexed data, making time series analysis much easier.

**Key Features:**
- **DatetimeIndex**: Specialized index for time data
- **Resampling**: Change frequency of time series data
- **Rolling Windows**: Calculate moving averages and statistics
- **Time Zone Support**: Handle different time zones
- **Period Operations**: Work with specific time periods

**Examples:**
"""

import pandas as pd
import numpy as np

# Creating the time series data
dates = pd.date_range('2023-01-01', periods=100, freq='D')
np.random.seed(42)
values = 100 + np.cumsum(np.random.randn(100))
ts = pd.Series(values, index=dates)

print("Original data (first 5):")
print(ts.head())

# Resample to monthly frequency
monthly = ts.resample('M').mean()
print("\nMonthly averages:")
print(monthly)

# Rolling window calculations
rolling_avg = ts.rolling(window=7).mean()
print("\n7-day moving average (last 5):")
print(rolling_avg.tail())

# Filter by date range
february = ts['2023-02-01':'2023-02-28']
print(f"\nFebruary data ({len(february)} days):")
print(february)

"""**Q20. What is the role of a pivot table in Pandas?**

**Ans:** **Pivot tables** reshape and summarize data, similar to Excel pivot tables. They group data by certain columns and apply aggregation functions.

**Uses:**
- **Data Summarization**: Aggregate data by categories
- **Cross-tabulation**: Show relationships between categorical variables
- **Reporting**: Create summary reports from detailed data

**Example:**

"""

import pandas as pd

# Sample data
data = pd.DataFrame({
    'Product': ['A', 'B', 'A', 'B'],
    'Region': ['North', 'South', 'North', 'South'],
    'Sales': [100, 150, 200, 250]
})

# Creates a pivot table to summarize sales by Product and Region
pivot_table = pd.pivot_table(data,
                             values='Sales',
                             index='Product',
                             columns='Region',
                             aggfunc='sum')

print(pivot_table)

"""
**Q21. Why is NumPy's array slicing faster than Python's list slicing?**

**Ans:** **NumPy slicing** is faster due to several technical advantages:

**Performance Reasons:**
- **Memory Layout**: Arrays stored in contiguous memory blocks
- **C Implementation**: Core operations written in optimized C code
- **No Python Objects**: Direct manipulation of memory, no Python overhead
- **Views vs Copies**: Slicing creates views (references) rather than copies when possible

**Example:**"""

import numpy as np
import time

# Large dataset
python_list = list(range(10000000))
numpy_array = np.array(python_list)

# Time Python list slicing
start = time.time()
list_slice = python_list[100:100000]
list_time = time.time() - start

# Time NumPy array slicing
start = time.time()
array_slice = numpy_array[100:100000]
array_time = time.time() - start

print(f"Python list slicing time: {list_time:.6f} seconds")
print(f"NumPy array slicing time: {array_time:.6f} seconds")
print(f"NumPy is {list_time/array_time}x faster!")
# NumPy is typically 10-100x faster

"""**Q22. What are some common use cases for Seaborn?**

**Ans:** **Seaborn** excels in statistical data visualization with many specialized plot types:

**Common Use Cases:**

**Exploratory Data Analysis:**
- `pairplot()`: Visualize all variable relationships
- `heatmap()`: Correlation matrices
- `distplot()`: Distribution analysis

**Statistical Relationships:**
- `scatterplot()`: Show correlations with regression lines
- `boxplot()`: Compare distributions across categories
- `violinplot()`: Detailed distribution shapes

**Categorical Data:**
- `countplot()`: Frequency of categorical variables
- `barplot()`: Compare means across categories
- `catplot()`: Complex categorical relationships

**Example:**
"""

import seaborn as sns
import matplotlib.pyplot as plt

# Loading built-in dataset
titanic = sns.load_dataset('titanic')

# Statistical visualization with one line
sns.boxplot(data=titanic, x='class', y='age', hue='survived')
plt.title('Age Distribution by Class and Survival')
plt.show()

# Shows age distributions, compares across passenger classes,
# and distinguishes between survivors and non-survivors

"""# Practical Questions"""

#Q1.

import numpy as np

# Creating a 2D array
arr = np.array([[1, 2, 3],
                [4, 5, 6]])

# Sum of each row
row_sums = np.sum(arr, axis=1)

print("2D Array:\n", arr)
print("Row-wise sum:", row_sums)

#Q2.

import pandas as pd

# Sample DataFrame
data = {'Name': ['Alice', 'Bob', 'Charlie'],
        'Marks': [85, 90, 78]}

df = pd.DataFrame(data)

# Finding the mean of the 'Marks' column
mean_marks = df['Marks'].mean()

print("Mean of Marks column:", mean_marks)

#Q3.

import matplotlib.pyplot as plt

# Sample data
x = [1, 2, 3, 4, 5]
y = [10, 12, 9, 14, 7]

# Scatter plot
plt.scatter(x, y)
plt.title("Scatter Plot")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.show()

#Q4.

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Sample data
df = pd.DataFrame({
    'A': [1, 2, 3, 4],
    'B': [4, 3, 2, 1],
    'C': [2, 3, 4, 5]
})

# Correlation matrix
corr = df.corr()

# Heatmap
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title("Correlation Heatmap")
plt.show()

#Q5.

import plotly.express as px
import pandas as pd

# Sample data
df = pd.DataFrame({
    'Fruits': ['Apple', 'Banana', 'Orange'],
    'Count': [10, 15, 7]
})

# Bar plot
fig = px.bar(df, x='Fruits', y='Count', title='Fruit Count')
fig.show()

#Q6.

import pandas as pd

# Original DataFrame
df = pd.DataFrame({
    'Name': ['A', 'B', 'C'],
    'Marks': [50, 60, 70]
})

# New column with 10 bonus marks
df['Total'] = df['Marks'] + 10

print(df)

#Q7.

import numpy as np

# Two arrays
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# Element-wise multiplication
result = a * b

print("Result:", result)

#Q8.

import matplotlib.pyplot as plt

# Sample data
x = [1, 2, 3, 4]
y1 = [2, 3, 4, 5]
y2 = [3, 2, 1, 0]

# Plotting
plt.plot(x, y1, label='Line 1')
plt.plot(x, y2, label='Line 2')

plt.title("Multiple Line Plot")
plt.xlabel("X")
plt.ylabel("Y")
plt.legend()
plt.show()

#Q9.

import pandas as pd

# Sample DataFrame
df = pd.DataFrame({
    'Name': ['A', 'B', 'C'],
    'Score': [65, 80, 45]
})

# Filter rows with Score > 60
filtered_df = df[df['Score'] > 60]

print(filtered_df)

#Q10.

import seaborn as sns
import matplotlib.pyplot as plt

# Sample data
data = [10, 20, 20, 30, 40, 40, 40, 50]

# Histogram
sns.histplot(data, bins=5, kde=True)
plt.title("Distribution Histogram")
plt.show()

#Q11.

import numpy as np

# Two matrices
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

# Matrix multiplication
result = A  @ B

print("Matrix Product:\n", result)

#Q12.

import pandas as pd

df = pd.read_csv('/content/Bank_churn.csv')

#first 5 rows

df.head()

#Q13.

import pandas as pd
import plotly.express as px


df = pd.read_csv('Bank_churn.csv')

# Using only the first 10 rows
df_small = df.head(10)

fig = px.scatter_3d(df_small,
                    x='CreditScore',
                    y='Balance',
                    z='EstimatedSalary',
                    color='Exited',
                    title='3D Scatter Plot (First 10 Customers)')

fig.show()